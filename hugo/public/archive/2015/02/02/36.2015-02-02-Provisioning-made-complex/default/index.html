<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Provisioning made more complex | oct.zoy.org</title>
<meta name="keywords" content="code, rant">
<meta name="description" content="Something’s going wrong.
I, as devops, or root, or whoever is in charge of configuring these servers, have to admit that there are now a LOT of provisionning tools available for us to work. This is probably a good thing in general (although looking at the number of js frameworks and the state of js development shows that this can be a bad thing) although one can but wonder:
WHICH ONE AM I TO USE ?">
<meta name="author" content="">
<link rel="canonical" href="https://oct.zoy.org/archive/2015/02/02/36.2015-02-02-provisioning-made-complex/default/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.9ece5999c00778a03c710e924aee5d11de71124f4ac26fb1046ad663031d846b.css" integrity="sha256-ns5ZmcAHeKA8cQ6SSu5dEd5xEk9Kwm&#43;xBGrWYwMdhGs=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js" integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://oct.zoy.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://oct.zoy.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://oct.zoy.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://oct.zoy.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://oct.zoy.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Provisioning made more complex" />
<meta property="og:description" content="Something’s going wrong.
I, as devops, or root, or whoever is in charge of configuring these servers, have to admit that there are now a LOT of provisionning tools available for us to work. This is probably a good thing in general (although looking at the number of js frameworks and the state of js development shows that this can be a bad thing) although one can but wonder:
WHICH ONE AM I TO USE ?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://oct.zoy.org/archive/2015/02/02/36.2015-02-02-provisioning-made-complex/default/" /><meta property="article:section" content="archive" />
<meta property="article:published_time" content="2015-02-02T18:00:00&#43;00:00" />
<meta property="article:modified_time" content="2015-02-02T18:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Provisioning made more complex"/>
<meta name="twitter:description" content="Something’s going wrong.
I, as devops, or root, or whoever is in charge of configuring these servers, have to admit that there are now a LOT of provisionning tools available for us to work. This is probably a good thing in general (although looking at the number of js frameworks and the state of js development shows that this can be a bad thing) although one can but wonder:
WHICH ONE AM I TO USE ?"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Archives",
      "item": "https://oct.zoy.org/archive/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Provisioning made more complex",
      "item": "https://oct.zoy.org/archive/2015/02/02/36.2015-02-02-provisioning-made-complex/default/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Provisioning made more complex",
  "name": "Provisioning made more complex",
  "description": "Something’s going wrong.\nI, as devops, or root, or whoever is in charge of configuring these servers, have to admit that there are now a LOT of provisionning tools available for us to work. This is probably a good thing in general (although looking at the number of js frameworks and the state of js development shows that this can be a bad thing) although one can but wonder:\nWHICH ONE AM I TO USE ?",
  "keywords": [
    "code", "rant"
  ],
  "articleBody": "Something’s going wrong.\nI, as devops, or root, or whoever is in charge of configuring these servers, have to admit that there are now a LOT of provisionning tools available for us to work. This is probably a good thing in general (although looking at the number of js frameworks and the state of js development shows that this can be a bad thing) although one can but wonder:\nWHICH ONE AM I TO USE ?\nAnd the fact is that each of them has its niceties and weaknesses. Most of them are backed by more or less large companies that can deliver certifications, support and everything cash can buy. But the truth is that choosing the right framework is difficult without too much prior experience. Our choice includes:\n cfengine puppet chef ansible salt stack  Each of these tools will have you deploy daemons, clients, SSL certificates, HTTP proxies and write some code before you can decide if the framework is for you. The technological price is quite huge and next times somebody trolls you with the fact that you are using 70% of the AWS services for your infrastructure, ask this ugly person whether its provisioning infrastructure is not « vendor-locked » too. Your provisioning tool must have some special abilities to be useful to you:\n It should run quickly on your grid, without creating too much load on the master, if it needs a master. Most of the time is spent in I/O, but sometimes, synchronous starts will load the master a lot: the underlying technology can become a problem (I’m looking at you ruby). It should be able to run « on-demand » so that you can trigger a grid update any time you want. It should be resilient. On this point, I tend to favorize provisioning tools that are not using the same taxonomy: tag: [backup] language as my main platform application, if possible. This way, when you start messing with runtime versions, you can be sure your provisioning tools will still be running… Deploying a ruby include fix on 30 servers by hand is painful, especially if you don’t have any csshx configuration around. It should be able to do some magic for you: you want to be able to add a frontend server on your grid and have the whole cluster reconfigured to use this new server automatically. This usually requires a search-capable master server for your provisioning (incompatible with master-less tools ?). It should be able to generate all your monitoring configuration from its own state. It should converge quickly. 2 steps convergence can be a PITA when you are in a hurry (incompatible with imperative tools?). Its logs should be easily accessible, centralized and API-manageable so that you can build a dashboard (or have it built-in?) with the state of the runs on your grid, have the ability to restart individual runs on servers.  Last time I checked, chef was almost the right tool and ansible, very close to it. But I’m still looking for the next tool…\nWhat’s your favorite provisioning tool? And Why?\n",
  "wordCount" : "513",
  "inLanguage": "en",
  "datePublished": "2015-02-02T18:00:00Z",
  "dateModified": "2015-02-02T18:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://oct.zoy.org/archive/2015/02/02/36.2015-02-02-provisioning-made-complex/default/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "oct.zoy.org",
    "logo": {
      "@type": "ImageObject",
      "url": "https://oct.zoy.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://oct.zoy.org/" accesskey="h" title="oct.zoy.org (Alt + H)">oct.zoy.org</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://oct.zoy.org/">Home</a>&nbsp;»&nbsp;<a href="https://oct.zoy.org/archive/">Archives</a></div>
    <h1 class="post-title">
      Provisioning made more complex
    </h1>
    <div class="post-meta"><span title='2015-02-02 18:00:00 +0000 UTC'>February 2, 2015</span>&nbsp;·&nbsp;3 min

</div>
  </header> 
  <div class="post-content"><!-- raw HTML omitted -->
<p>Something’s going wrong.</p>
<p>I, as devops, or root, or whoever is in charge of configuring these servers, have to admit that there are now a LOT of provisionning tools available for us to work. This is probably a good thing in general (although looking at the number of js frameworks and the state of js development shows that this can be a bad thing) although one can but wonder:</p>
<p><strong>WHICH ONE AM I TO USE ?</strong></p>
<p>And the fact is that each of them has its niceties and weaknesses. Most of them are backed by more or less large companies that can deliver certifications, support and everything cash can buy. But the truth is that choosing the right framework is difficult without too much prior experience. Our choice includes:</p>
<ul>
<li><a href="http://cfengine.com/">cfengine</a></li>
<li><a href="https://puppetlabs.com/">puppet</a></li>
<li><a href="https://www.chef.io/chef/">chef</a></li>
<li><a href="http://www.ansible.com/home">ansible</a></li>
<li><a href="http://saltstack.com/">salt stack</a></li>
</ul>
<p>Each of these tools will have you deploy daemons, clients, SSL certificates, HTTP proxies and write some code before you can decide if the framework is for you. The technological price is quite huge and next times somebody trolls you with the fact that you are using 70% of the AWS services for your infrastructure, ask this ugly person whether its provisioning infrastructure is not « vendor-locked » too.
Your provisioning tool must have some special abilities to be useful to you:</p>
<ul>
<li>It should run quickly on your grid, without creating too much load on the master, if it needs a master. Most of the time is spent in I/O, but sometimes, synchronous starts will load the master a lot: the underlying technology can become a problem (I’m looking at you ruby).</li>
<li>It should be able to run « on-demand » so that you can trigger a grid update any time you want.</li>
<li>It should be resilient. On this point, I tend to favorize provisioning tools that are not using the same taxonomy:
tag: [backup]
language as my main platform application, if possible. This way, when you start messing with runtime versions, you can be sure your provisioning tools will still be running… Deploying a ruby <code>include</code> fix on 30 servers by hand is painful, especially if you don’t have any <a href="https://code.google.com/p/csshx/">csshx</a> configuration around.</li>
<li>It should be able to do some magic for you: you want to be able to add a frontend server on your grid and have the whole cluster reconfigured to use this new server automatically. This usually requires a search-capable master server for your provisioning (incompatible with master-less tools ?).</li>
<li>It should be able to generate all your monitoring configuration from its own state.</li>
<li>It should converge quickly. 2 steps convergence can be a PITA when you are in a hurry (incompatible with imperative tools?).</li>
<li>Its logs should be easily accessible, centralized and API-manageable so that you can build a dashboard (or have it built-in?) with the state of the runs on your grid, have the ability to restart individual runs on servers.</li>
</ul>
<p>Last time I checked, <code>chef</code> was almost the right tool and <code>ansible</code>, very close to it. But I’m still looking for the next tool…</p>
<p>What’s your favorite provisioning tool? And Why?</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://oct.zoy.org/tags/code/">code</a></li>
      <li><a href="https://oct.zoy.org/tags/rant/">rant</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://oct.zoy.org/">oct.zoy.org</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
